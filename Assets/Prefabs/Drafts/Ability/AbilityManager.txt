using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class AbilityManager : MonoBehaviour
{
    [Header("ScriptableObjects")]
    [SerializeField] PathHolder somatoHolder;
    [SerializeField] PathHolder oneroHolder;
    [SerializeField] PathHolder aetherHolder;

    [Header("Base Kit")]

    [SerializeField] private Ability basePassive;
    [SerializeField] private Ability breadAndButter;

    [Header("Paths")]
    [SerializeField] private Path somato;
    [SerializeField] private Path aether;
    [SerializeField] private Path onero;

    private int currentPathIndex= 0;

    private Path[] switcher;
    private List<Ability> basics;


    private void Start()
    {
        //Load Character


        //temp

        MakeAbility(basePassive.gameObject, basePassive, 1);
        MakeAbility(breadAndButter.gameObject, breadAndButter, 2);

        basics = new List<Ability> { basePassive, breadAndButter };

        somato = new Path(transform, somatoHolder);
        onero = new Path(transform, oneroHolder);
        aether= new Path(transform, aetherHolder);

        switcher = new Path[] { somato, onero, aether };
        switcher[currentPathIndex].Enable();

    }

    private void MakeAbility(GameObject template, Ability ability, int slotIndex)
    {
        GameObject holder = Instantiate(template);
        holder.transform.parent = transform;

        ability = holder.GetComponent<Ability>();
        holder.name = ability.getEffect().AbilityData.EffectName;
        ability.Initialize(slotIndex);
    }

    /// <summary>
    /// Retrieves an Ability Effect from an enabled ability
    /// </summary>

    public void getEffect(Parameters p)
    {
        string ID = p.GetStringExtra("AbilityID", "");

        if (string.IsNullOrEmpty(ID))
            return;

       
        foreach (var ability in basics)
        {
            AbilityEffect effect = ability.getEffect(ID);

            if (effect == null)
                continue;

            p.PutObjectExtra("Ability Effect", effect);
            break;
        }

        Path currentPath = switcher[currentPathIndex];
        p.PutObjectExtra("Ability Effect", currentPath.getEffect(ID));

    }

    public void SwitchPaths(int dir)
    {
        if (dir == 0) return;
        dir /= Mathf.Abs(dir);

        //currentPathIndex = (currentPathIndex + dir) % switcher.Length;

        currentPathIndex += dir;
        if (currentPathIndex >= switcher.Length)
            currentPathIndex = 0;
        if (currentPathIndex < 0)
            currentPathIndex = switcher.Length - 1;

        Parameters p = new Parameters();
        p.PutExtra("Path Index", currentPathIndex);
        EventBroadcaster.Instance.PostEvent(EventNames.ABILITY_EVENTS.ON_PATH_CHANGED, p);

        for(int i =0; i < switcher.Length; i++)
        {
            if(currentPathIndex == i)
                switcher[i].Enable();
            else switcher[i].Disable();
        }

    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.O))
            SwitchPaths(1);

        if (Input.GetKeyDown(KeyCode.P))
            SwitchPaths(-1);
    }


    #region Singleton

    public static AbilityManager Instance { get; private set; } = null;
    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else Destroy(gameObject);

        EventBroadcaster.Instance.AddObserver(EventNames.ABILITY_EVENTS.ON_GET_EFFECT, getEffect);
    }

    #endregion
}
