using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class MultiCast : Ability
{
    /*
    [Serializable]
    private class RecastInfo
    {
        [SerializeField] public float cooldownBetweenCasts = 0.5f;
        [SerializeField] public bool canRecastWhileCurrentlyActive = true;
    }

    [Header("Ability Settings")]
    [SerializeField] private SerializableDictionary<AbilityEffect, RecastInfo> subsequentCasts;
    [SerializeField] private float maxRecastableDuration;
    [SerializeField] private bool resetOnDisable = false;
    [SerializeField] private RecastInfo baseEffectInfo;

    private float recastableDuration;
    private int effectIndex;
    private bool[] runningEffects;

    protected override void Start()
    {
        /*
            EffectIndex is denoted by numbers between 0 and the size of Recasts
                > 0 - Recasts.Size - 1 are the keys within the subsequent casts
                > Recast.Size refers to the effect variable inherited from ability 
         
        base.Start();
        effectIndex = subsequentCasts.elements.Length;
        runningEffects = new bool[subsequentCasts.elements.Length + 1];

    }

    private void Update()
    {

        if (!isEnabled) 
            return;

        UpdateRecastWindow();
        cooldown.Update(slotIndex);

    }


    private void UpdateRecastWindow()
    {
        if (recastableDuration <= 0)
            return;

        recastableDuration -= Time.deltaTime;

        if (recastableDuration <= 0)
        {
            cooldown.currentCooldown = effect.AbilityData.Cooldown;
            effectIndex = subsequentCasts.elements.Length;

            ChangeEffect(effect);
        }

    }

    public override void Activate()
    {

        if (!isEnabled || cooldown.currentCooldown > 0)
            return;

        int p = PreviousIndex();

        bool abortRecast = !subsequentCasts.elements[p].value.canRecastWhileCurrentlyActive && runningEffects[p];

        if (abortRecast)
        {
            Debug.Log("Previous cast is still running and cannot run simultaneously with the new one");
            return;
        }
           
        IEnumerator Cast()
        {
            int currentEffect = effectIndex;
            runningEffects[currentEffect] = true;
            var toRun = getEffect();
            NextEffect();
            cooldown.currentCooldown = subsequentCasts.elements[effectIndex].value.cooldownBetweenCasts;

            Parameters p = new Parameters();
            p.PutObjectExtra("Player", Player.Instance);

            yield return toRun.Cast(p);
            runningEffects[currentEffect] = false;
        }

        StartCoroutine(Cast());

        if (isCurrentEffectDefault())
            recastableDuration = maxRecastableDuration;

    }

    public override void setEnabled(bool enabled, bool willResetCooldown = false)
    {

        if (resetOnDisable)
        {
            effectIndex = subsequentCasts.elements.Length;
            ChangeEffect(effect);
        }

        isEnabled = enabled;

        if (willResetCooldown)
            cooldown.Reset();

        Parameters p = new Parameters();
        p.PutExtra("Enabled", enabled);
        EventBroadcaster.Instance.PostEvent(EventNames.ABILITY_EVENTS.ON_ABILITY_SET_ACTIVE, p);
    }

    private void NextEffect()
    {
        effectIndex = ++effectIndex % (subsequentCasts.elements.Length + 1);
        AbilityEffect effect = getEffect();
        ChangeEffect(effect);
        cooldown.maxCooldown = isCurrentEffectDefault() ? effect.AbilityData.Cooldown : subsequentCasts.elements[effectIndex].value.cooldownBetweenCasts;
    }

    private AbilityEffect getEffect()
    {
        if(effectIndex < subsequentCasts.elements.Length)
            return subsequentCasts.elements[effectIndex].key;
        return effect;
    }
    
    private int PreviousIndex()
    {
        return effectIndex > 0 ? effectIndex - 1 : subsequentCasts.elements.Length;
    }

    private bool isCurrentEffectDefault()
    {
        return effectIndex == subsequentCasts.elements.Length;
    }
*/
    public override void Activate()
    {
        throw new NotImplementedException();
    }

    public override AbilityEffect getEffect(string id = "")
    {
        throw new NotImplementedException();
    }

    public override void setEnabled(bool enabled)
    {
        throw new NotImplementedException();
    }
}